# based on by Zachary Burchill zashmagic.py (https://gist.github.com/burchill/4adb9531a246e8c27752c1b19e0236bb)
# Feel free to use/modify however you want, but be nice and
#   please give me credit/attribution.
#
# Put this file in your jupyter directory and load it in the first cell with:
#   %load_ext dev_magic
# After that, you can use %%export in the cells.


import os
import re
import importlib
import subprocess
from pathlib import Path

import black
from IPython.core.magic import Magics, cell_magic, magics_class, needs_local_scope
from IPython.core.magic_arguments import argument, magic_arguments, parse_argstring


def create_inits(package_path: Path, levels: list[str]):
    base = package_path

    for level in levels:
        os.makedirs(base, exist_ok=True)
        init = f"{base}/__init__.py"
        if not Path(init).exists():
            Path(init).touch()
            print(f"created {init} file.")

        base = f"{base}/{level}"


def resolve_line(line: str, context: dict) -> str:
    needs_resolve = re.findall(r"#\s*export:\s*resolve.*", line)
    if not needs_resolve:
        return line

    print(needs_resolve)
    line = re.sub(r"#.*", "", line)

    if assign := re.findall(r"^\w+\s*=", line):
        line = line.replace(assign[0], "")

    vars_ = re.sub(r"#\s*resolve:\s*", "", needs_resolve[0])
    print(vars_)
    vars_ = vars_.split(" ")
    print(vars_)

    # clear line
    for var in context.keys():
        value = context[var]
        line = re.sub(var, str(value), line)

    return assign[0] + line


def hide_block(cell: str) -> str:
    block_pattern = re.compile(r"#\s*export:\s*(start|end) hide")
    matches = block_pattern.findall(cell)
    if len(matches) % 2:
        raise ValueError("hide blocks must be in start-end pairs")

    lines = []
    in_hide_block = False
    for line in cell.split("\n"):
        if block_pattern.findall(line):
            # toogle hide block
            in_hide_block = not in_hide_block
        if not in_hide_block:
            lines.append(line)

    return "\n".join(lines)


@magics_class
class DevMagics(Magics):
    @magic_arguments()
    @argument("output", help="file or submodule path to write to.")
    @argument("-a", "--append", action="store_true", help="Optional. append to file.")
    @needs_local_scope
    @cell_magic
    def export(self, line, cell, local_ns=None):
        """ """
        local_ns = local_ns
        args = parse_argstring(self.export, line)

        # get notebook path
        # if jupyter is runing on vscode
        notebook_path = local_ns.get("__vsc_ipynb_file__", "")
        notebook_dir = local_ns.get("_dh", "")
        if not notebook_path:
            print(
                "WARNING: I don't know how to get current notebook path outside vscode.",
                "Until then, the output will be without it's notebook reference",
            )

        # first run the cell
        self.shell.run_cell(cell)

        # process exported lines
        cell = hide_block(cell)
        lines = cell.split("\n")
        lines = filter(
            lambda x: not re.findall(r"#.*export:\s*(start|end)?\s*hide", x),
            lines,
        )
        # lines = map(lambda x: resolve_line(x, local_ns), lines)
        lines = list(lines)
        cell = "\n".join(lines)

        if args.output[0] in ["/", "."] or args.output.endswith(".py"):  # it is a path
            print("output handled as path")
            filename = args.output
        else:
            levels = args.output.split(".")

            package = importlib.import_module(levels[0])
            package_path = package.__path__[0]

            submodule_path = "/".join(levels[1:])
            submodule_path = submodule_path.replace("-", "_")

            filename = f"{package_path}/{submodule_path}.py"
            print(f"output handled as submodule of {levels[0]}")
            create_inits(package_path, levels[1:])

        # adds %%writefile
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        writefile_cmd = ["%%writefile", "-a" if args.append else "", filename]
        writefile_cmd = " ".join(writefile_cmd)

        # adds header
        header = [
            "# codeblock generated by devtools",
            f"# source: {notebook_path}",
            "",
        ]
        header = "\n".join(header)

        cmd = [writefile_cmd, header, cell]
        cmd = "\n".join(cmd)
        self.shell.run_cell(cmd)

        # run black
        cmd = f"black -q {filename}"
        subprocess.run(cmd.split())

        # run isort
        cmd = f"isort {filename}"
        subprocess.run(cmd.split())


# This needs to be in the file so Jupyter registers the magics when it's loaded
def load_ipython_extension(ipython):
    ipython.register_magics(DevMagics)
