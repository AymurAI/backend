# codeblock generated by devtools
# source: /workspace/notebooks/dev/patterns/03-sections-spot/01-keywords.ipynb

from copy import deepcopy
from functools import reduce

import spacy
from spacy.tokens import Span

from aymurai.utils.misc import get_element
from aymurai.spacy.utils import format_entity
from aymurai.meta.pipeline_interfaces import Transform
from aymurai.spacy.components.regex import EnhancedRegexMatcher
from aymurai.spacy.components.utils import filter_overlapping_matches
from aymurai.datasets.ar_juz_pcyf_10 import ArgentinaJuzgadoPCyF10Dataset

FIELDS = ["tipo_de_resolucion", "objeto_de_la_resolucion", "detalle", "decision"]
VALIDATION_FIELDS = ArgentinaJuzgadoPCyF10Dataset("validation-fields").data
VALIDATION_FIELDS = {k: v for k, v in VALIDATION_FIELDS.items() if k in FIELDS}


class SpacyRulerKeywords(Transform):
    def __init__(self):
        global __nlp
        __nlp = spacy.blank("es")
        self.matcher = EnhancedRegexMatcher(__nlp.vocab)

        for field, validations in VALIDATION_FIELDS.items():
            if field == "tipo_de_resolucion":
                validations = [f"resoluci[oÃ³]n_{v}" for v in validations]

            validations += [v.replace("_", "[_\s]+") for v in validations]

            self.matcher.add(field, patterns=validations)

    def __call__(self, item):
        item = deepcopy(item)
        if not "entities" in item["data"]:
            item["data"]["entities"] = []

        # skip if there are no section parser
        if not (sections := get_element(item, ["data", "spans", "section"], [])):
            return item

        sections = filter(
            lambda x: x["label"] in ["KEYWORDS"],
            sections,
        )
        sections = sorted(sections, key=lambda e: e["start"])

        if not sections:
            return item

        offset = sections[0]["start"]

        doc = __nlp(item["data"]["doc.text"])
        matches = self.matcher(doc)

        # sort by score, lenght and position
        matches = filter(lambda x: x[1] > offset, matches)
        matches = sorted(matches, key=lambda x: (sum(x[3]), -(x[2] - x[1]), x[1]))
        matches = filter_overlapping_matches(matches)
        matches = list(matches)

        for label, start, end, score in matches:
            span = Span(doc, start=start, end=end, label=label)
            item["data"]["entities"] += [format_entity(span)]

        return item
