# codeblock generated by devtools
# source: /workspace/notebooks/dev/patterns/01-datetimes/02-start-times.ipynb


from copy import deepcopy

import spacy
import pandas as pd
from more_itertools import zip_offset

from aymurai.meta.types import DataItem, DataBlock
from aymurai.spacy.components.fuzzy import FuzzyMatcher
from aymurai.meta.pipeline_interfaces import TrainModule


class DummyExtractorHoraInicioCierre(TrainModule):
    def __init__(self, lang: str = "es"):
        self.nlp = spacy.blank("es")
        self.matcher = FuzzyMatcher(self.nlp.vocab)
        self.matcher.add("START", patterns=[self.nlp.make_doc(t) for t in ["inicio"]])
        self.matcher.add(
            "END",
            patterns=[
                self.nlp.make_doc(t) for t in ["cierre", "finalizacion", "finalizaciÃ³n"]
            ],
        )

    def save(self, path: str):
        return

    def load(self, path: str):
        return

    def fit(self, train: DataBlock, val: DataBlock):
        return

    def predict(self, data: DataBlock) -> DataBlock:
        data = [self.predict_single(item) for item in data]

        return data

    def predict_single(self, item: DataItem) -> DataItem:
        item = deepcopy(item)

        # format prediction
        if "predictions" not in item:
            item["predictions"] = {}
        if "records" not in item["predictions"]:
            item["predictions"]["records"] = {}
        if "entities" not in item["predictions"]:
            item["predictions"]["entities"] = []
        if "doc-cats" not in item["predictions"]:
            item["predictions"]["doc-cats"] = {}

        item["predictions"]["records"]["hora_de_inicio"] = []
        item["predictions"]["records"]["hora_de_cierre"] = []
        item["predictions"]["records"]["duracion"] = []
        item["predictions"]["doc-cats"]["oral_escrita"] = "escrita"

        ents = []
        if "entities" in item["data"]:
            ents += item["data"]["entities"]

        # if there is no entities just pass
        if not ents:
            return item

        times = filter(lambda x: x["label"] == "TIME", ents)
        times = sorted(times, key=lambda e: e["start"])

        if not times:
            return item

        starts = ends = 0
        for span in times:
            pre = span["context_pre"]
            dt = span["attrs"]["aymurai_date"]

            matches = self.matcher(self.nlp.make_doc(pre))
            matches = sorted(matches, key=lambda x: x[3])
            if not matches:
                continue

            candidate = matches[0]
            match candidate[0]:
                case "START":
                    span["label"] = "HORA_INICIO"
                    item["predictions"]["entities"].append(span)
                    item["predictions"]["records"]["hora_de_inicio"].append(dt)
                    item["predictions"]["doc-cats"]["oral_escrita"] = "oral"
                    starts += 1
                case "END":
                    span["label"] = "HORA_CIERRE"
                    item["predictions"]["entities"].append(span)
                    item["predictions"]["records"]["hora_de_cierre"].append(dt)
                    item["predictions"]["doc-cats"]["oral_escrita"] = "oral"
                    ends += 1

        pairs = max(starts, ends)
        item["predictions"]["records"]["hora_de_inicio"] = [
            time
            for i, time in zip_offset(
                range(pairs),
                item["predictions"]["records"]["hora_de_inicio"],
                offsets=(0, 0),
                longest=True,
                fillvalue=pd.NaT,
            )
        ]
        item["predictions"]["records"]["hora_de_cierre"] = [
            time
            for i, time in zip_offset(
                range(pairs),
                item["predictions"]["records"]["hora_de_cierre"],
                offsets=(0, 0),
                longest=True,
                fillvalue=pd.NaT,
            )
        ]
        for start, end in zip(
            item["predictions"]["records"]["hora_de_inicio"],
            item["predictions"]["records"]["hora_de_cierre"],
        ):
            item["predictions"]["records"]["duracion"] += [end - start]

        return item
